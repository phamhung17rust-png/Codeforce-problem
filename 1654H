#include<bits/stdc++.h>
using ll=long long;
const ll N=((1<<19)+5),M=(100+5),mod=998244353;
using namespace std;
int n,m,A[N],B[N];ll E[N],D[N],Ans,frc[N],Inv[N],P[N],G1[M][N],G2[M][N],F1[N],F2[N];char S[N];
ll mpow(ll x,int y=mod-2){ll Ans=1;while(y) y&1&&(Ans=Ans*x%mod),y>>=1,x=x*x%mod;return Ans;}const int G=3,InvG=mpow(G);
ll C(int x,int y){return frc[x]*Inv[y]%mod*Inv[x-y]%mod;}
int tr[N+5],k;void Init(int n){k=1;while(k<=n+1)k<<=1;for(ll i=0;i<k;i++)tr[i]=(tr[i>>1]>>1)|(i&1?k/2:0),E[i]=D[i]=0;}
void NTT(ll *A,int n,int flag){
ll i,j,h;ll key,now,pus;for(i=0;i<n;i++) i<tr[i]&&(swap(A[i],A[tr[i]]),0);for(i=2;i<=n;i<<=1){
for(key=mpow(flag?G:InvG,(mod-1)/i),j=0;j<n;j+=i){
for(now=1,h=j;h<j+i/2;h++) pus=now*A[h+i/2]%mod,A[h+i/2]=(A[h]-pus+mod)%mod,A[h]=(A[h]+pus)%mod,now=now*key%mod;
}
}if(flag) return;ll invn=mpow(n);for(i=0;i<n;i++) A[i]=A[i]*invn%mod;
}void Solve(int l,int r,int op,ll *F){
if(l==r){if(op){for(ll i=1;i<=min(m,l-1);i++) F[l]=((G2[i][l]-P[l-i+1]+mod)*F[i]%mod*C(l-2,i-1)+F[l])%mod;}if(l==1) F[1]=1;return;}
ll i,m=l+r>>1,L1=m-l+1,L2=r-m;Solve(l,m,op,F);Init(L1*2+L2);for(i=0;i<L1;i++) E[i]=F[l+i]*Inv[l+i-1]%mod;for(i=0;i<L1+L2;i++) D[i]=P[i+1]*(i?Inv[i-1]:0);
NTT(E,k,1);NTT(D,k,1);for(i=0;i<k;i++) E[i]=E[i]*D[i]%mod;NTT(E,k,0);for(i=L1;i<L1+L2;i++) F[l+i]=(E[i]*frc[l+i-2]+F[l+i])%mod;
Solve(m+1,r,op,F);
}main(){
ll i,j;scanf("%d%d%s",&n,&m,S+1);for(i=1;i<n;i++)i>m?(A[i]=B[i]=1):(S[i]^'<'?(A[i]=1):(B[i]=1));
for(frc[0]=Inv[0]=i=1;i<=n;i++) frc[i]=frc[i-1]*i%mod,Inv[i]=mpow(frc[i]);
for(P[2]=P[3]=1,i=4;i<=n;i++) P[i]=P[i-1]*2%mod;
for(i=m;i;i--){G2[i][i+1]=A[i];G1[i][i+1]=B[i];G1[i][i+2]=G2[i][i+2]=B[i]*A[i+1];
for(j=i+3;j<=n;j++)G1[i][j]=G2[i][j]=B[i]*A[j-1]*((i^m?G2[i+1][j]:P[j-i])+G1[i][j-1])%mod;
}Solve(1,n,1,F1);Solve(1,n-m,0,F2);reverse(F2+1,F2+n+1);for(i=m;i;i--) for(j=i+1;j<=n;j++) F2[i]=(F2[i]+F2[j]*G1[i][j]%mod*C(n-i-1,n-j))%mod;
for(i=1;i<=n;i++)Ans+=F1[i]*F2[i]%mod*C(n-1,i-1)%mod;printf("%lld\n",Ans%mod);
}
