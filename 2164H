#include<bits/stdc++.h>
using namespace std;

const int MAXN = 500005;
const int A = 26;
const int K = 4;

string s;
int n, q;

int nxt[MAXN][A];
int fail[MAXN][A];
int link[MAXN];
int jump[MAXN];
int len[MAXN];
vector<int> tree[MAXN];
int ta[MAXN], tb[MAXN];
int pos[MAXN];
int node_cnt;

int ft[MAXN];

void ft_update(int i, int x) {
while (i < n) {
ft[i] = max(ft[i], x);
i |= i + 1;
}
}

int ft_query(int i) {
int res = -1;
while (i >= 0) {
res = max(res, ft[i]);
i &= i + 1;
i--;
}
return res;
}

int seg1[MAXN * 4], seg2[MAXN * 4];
int seg_size;

void build_seg() {
seg_size = 1;
while (seg_size < n + 2) seg_size <<= 1;
fill(seg1, seg1 + seg_size * 2, -1);
fill(seg2, seg2 + seg_size * 2, -1);
}

void seg1_update(int i, int x) {
i += seg_size;
seg1[i] = max(seg1[i], x);
while (i > 1) {
i >>= 1;
seg1[i] = max(seg1[i << 1], seg1[i << 1 | 1]);
}
}

int seg1_query(int l, int r) {
int res = -1;
l += seg_size; r += seg_size;
while (l <= r) {
if (l & 1) res = max(res, seg1[l++]);
if (!(r & 1)) res = max(res, seg1[r--]);
l >>= 1; r >>= 1;
}
return res;
}

void seg2_update(int l, int r, int x) {
l += seg_size; r += seg_size;
while (l <= r) {
if (l & 1) seg2[l] = max(seg2[l], x), l++;
if (!(r & 1)) seg2[r] = max(seg2[r], x), r--;
l >>= 1; r >>= 1;
}
}

int seg2_query(int i) {
int res = -1;
i += seg_size;
while (i > 0) {
res = max(res, seg2[i]);
i >>= 1;
}
return res;
}

int new_node(int l) {
len[node_cnt] = l;
return node_cnt++;
}

int timer = 0;
void dfs(int u) {
ta[u] = timer++;
for (int v : tree[u]) dfs(v);
tb[u] = timer;
}

void build_eertree() {
node_cnt = 0;
new_node(0);
new_node(-1);

for (int a = 0; a < A; a++) {  
    fail[0][a] = fail[1][a] = 1;  
}  
link[0] = link[1] = 1;  
jump[0] = jump[1] = 1;  
tree[1].push_back(0);  
  
int cur = 0;  
for (int i = 0; i < n; i++) {  
    int c = s[i] - 'a';  
      
    while (i - len[cur] - 1 < 0 || s[i - len[cur] - 1] != s[i]) {  
        cur = fail[cur][c];  
    }  
      
    if (!nxt[cur][c]) {  
        int u = new_node(len[cur] + 2);  
        int f = nxt[fail[cur][c]][c];  
          
        link[u] = f;  
          
        if (f == 0 || len[u] - len[f] != len[f] - len[link[f]]) {  
            jump[u] = f;  
        } else {  
            jump[u] = jump[f];  
        }  
          
        memcpy(fail[u], fail[f], sizeof(fail[f]));  
        fail[u][s[i - len[f]] - 'a'] = f;  
          
        tree[f].push_back(u);  
        nxt[cur][c] = u;  
    }  
      
    pos[i] = cur = nxt[cur][c];  
}  
  
dfs(1);

}

int main() {
ios_base::sync_with_stdio(false);
cin.tie(NULL);

cin >> n >> q >> s;  
  
vector<vector<int>> queries(n);  
vector<int> query_start(q);  
  
for (int h = 0; h < q; h++) {  
    int l, r;  
    cin >> l >> r;  
    l--; r--;  
    query_start[h] = l;  
    queries[r].push_back(h);  
}  
  
build_eertree();  
build_seg();  
fill(ft, ft + n, 0);  
  
vector<int> ans(q);  
  
for (int j = 0; j < n; j++) {  
    int u = pos[j];  
      
    if (u) {  
        int i = seg1_query(ta[u], tb[u] - 1);  
        if (i != -1) {  
            ft_update(n - 1 - (i - len[u] + 1), len[u]);  
        }  
    }  
      
    int v = u;  
    while (v) {  
        ft_update(n - 1 - (j - len[v] + 1), len[link[v]]);  
          
        int w = jump[v];  
        int d = len[v] - len[link[v]];  
          
        if (w) {  
            int i = seg1_query(ta[w], tb[w] - 1);  
            if (i != -1) {  
                ft_update(n - 1 - (i - len[w] + 1), len[w]);  
            }  
        }  
          
        for (int k = 1; k <= K && len[w] + d * k <= len[v]; k++) {  
            int i = j - len[w] - d * k + 1;  
            ft_update(n - 1 - i, len[w] + d * (k - 1));  
        }  
          
        if (len[v] - len[w] >= d * K) {  
            int i = j - len[w] - d * K + 1;  
            seg2_update(j - len[v] + 2, i, j);  
        }  
          
        v = w;  
    }  
      
    seg1_update(ta[u], j);  
      
    for (int h : queries[j]) {  
        int i = query_start[h];  
        int x = ft_query(n - 1 - i);  
          
        int j_ = seg2_query(i);  
        if (j_ != -1 && j_ >= i) {  
            u = pos[j_];  
            while (j_ - len[jump[u]] + 1 < i) {  
                u = jump[u];  
            }  
              
            int d = len[u] - len[link[u]];  
            int i_ = j_ - len[u] + 1;  
            i_ += (i - i_ + d - 1) / d * d;  
              
            x = max(x, j_ - i_ + 1 - d);  
            if (i_ > i) {  
                x = max(x, j_ - i_ - (d - i_ + i) * 2 + 1);  
            }  
        }  
          
        ans[h] = x;  
    }  
}  
  
for (int h = 0; h < q; h++) {  
    cout << ans[h] << '\n';  
}  
  
return 0;

}